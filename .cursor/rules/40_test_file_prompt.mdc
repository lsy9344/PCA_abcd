---
description:
globs:
alwaysApply: false
---
당신은 이 레포지토리의 **테스트 아키텍처 책임자**입니다. 목표는 여러 매장(예: `a_store_crawler.py`, `b_store_crawler.py`, `d_store_crawler.py` …)이 존재하는 공용 프로젝트에서, **테스트가 소스 코드를 ‘실행만’ 하고 결과만 검증**하도록 테스트 구조를 통일하는 것입니다.  
현재 일부 `test_*.py`는 브라우저 생성, 셀렉터 조작, 팝업 처리, 쿠폰 계산/적용 등의 비즈니스/DOM 로직을 **테스트 내부에서 중복 구현**하고 있습니다. 이를 제거하고, **각 매장의 크롤러 퍼블릭 API만 호출**하는 구조로 변경하세요.

---

## ✅ 미션 (전 매장 공통)

1) **표준 퍼블릭 API 규격 정의**
   - 모든 매장 크롤러가 아래 시그니처(또는 동등 기능)로 동작하도록 **어댑터/래퍼**를 제공합니다. (기존 각 매장의 메서드명이 다르면 어댑터에서 매핑)
   - 표준 인터페이스(Protocol/ABC) 예시:
     - `start() -> None` (브라우저/컨텍스트 초기화)
     - `login() -> bool`
     - `search_vehicle(car_number: str) -> bool`
     - `get_coupon_history(car_number: str) -> CouponHistory` *(없다면 최소 상태를 표현하는 공용 도메인 모델/딕셔너리로 표준화)*
     - `apply_coupons(applications: list[CouponApplication]) -> bool`
     - `cleanup() -> None`

2) **매장별 크롤러 어댑터 & 등록소 구성**
   - `adapters/store_registry.py`를 만들고, `STORE_REGISTRY: dict[str, StoreAdapter]` 형태로 `{ "a": AStoreAdapter, "b": BStoreAdapter, "d": DStoreAdapter, ... }` 매핑을 제공합니다.
   - 각 어댑터는 해당 매장의 실제 크롤러 클래스를 감싸 **표준 API**를 충족해야 합니다.

3) **설정/시크릿/브라우저 옵션 로더 통일**
   - `infrastructure/config/loader.py`에 공용 로더 구현:
     - `load_store_config(store_id: str) -> StoreConfig`
     - `load_runtime_options() -> RuntimeOptions` *(headless, timezone, viewport, download_dir 등)*
   - **테스트와 실제 실행이 같은 로더**를 사용합니다. 테스트에서 YAML/ENV를 직접 읽지 말고 위 로더만 사용하세요.

4) **테스트를 ‘얇은 실행 래퍼’로 재구성 (전 매장 공용 E2E)**
   - `tests/e2e/test_store_e2e.py`를 만들고 **모든 매장**을 파라미터로 돌리는 단일 E2E 테스트를 작성합니다.
   - `pytest.mark.parametrize("store_id", STORE_REGISTRY.keys())`로 전 매장을 커버합니다.
   - 테스트는 다음 절차만 수행하고 **DOM/셀렉터/팝업을 직접 다루지 않습니다**:
     1) 어댑터 인스턴스 생성 (`store_id`로 로더/옵션 주입)
     2) `start()` → `login()` → `search_vehicle(test_car_number)`
     3) `get_coupon_history(...)`로 현재 상태 조회/검증
     4) (있다면) **공통 쿠폰 계산기**로 계획 수립 → `apply_coupons(plan)`
     5) `cleanup()`
   - 모든 검증은 **퍼블릭 API 반환값/도메인 모델**로만 수행합니다 (`assert bool/len/필드값`).

5) **레거시 UI 테스트 격리**
   - 기존 `test_*_ui.py` 중 브라우저 직접 생성, 셀렉터/팝업 조작, `wait_for_timeout` 등 **중복 구현 코드**는 제거합니다.
   - 바로 제거가 어렵다면 `tests/legacy/test_*_ui_legacy.py`로 이동하고 `@pytest.mark.skip(reason="legacy UI flow")` 처리합니다.

6) **동일 실행 보장 규칙**
   - 테스트에서 **브라우저 직접 생성 금지**. 크롤러(또는 어댑터) 내부 초기화만 사용합니다.
   - `sys.path.append('.')` 금지. **패키지/절대 임포트**와 `pip install -e .` 전제를 사용합니다.
   - 파일 경로는 항상 `Path(__file__).resolve()` 기준 절대경로로 처리합니다.
   - `wait_for_timeout` 사용 금지 → **locator/상태 기반 explicit wait**만 허용(이는 크롤러/어댑터 내부에서 처리).
   - 로깅/알림(텔레그램 등)은 **주입 인터페이스**만 사용하고, 테스트 코드가 직접 외부 통신을 열지 않습니다.
   - 민감정보는 환경변수/시크릿에서 로딩하고 테스트 소스에 하드코딩하지 않습니다.

---

## 📦 산출물

1) `adapters/store_registry.py`
   - `STORE_REGISTRY` 매핑과 `get_store_adapter(store_id: str) -> StoreAdapter` 제공.
   - 각 매장 어댑터 구현(필요 시 `adapters/<store_id>_adapter.py` 분리) → 내부에서 해당 매장의 실제 크롤러 인스턴스를 생성/보유하고 표준 API로 노출.

2) `infrastructure/config/loader.py`
   - `load_store_config(store_id)` / `load_runtime_options()` 구현.
   - (없다면) 공통 도메인 타입 정의(`CouponHistory`, `CouponApplication` 등 최소 필드)도 정리.

3) `tests/e2e/test_store_e2e.py`
   - 예시 스켈레톤 (필요에 맞게 보완):
     ```python
     import os
     import pytest
     from adapters.store_registry import STORE_REGISTRY, get_store_adapter

     TEST_CAR_NUMBER = os.getenv("TEST_CAR_NUMBER", "12가1234")

     @pytest.mark.parametrize("store_id", sorted(STORE_REGISTRY.keys()))
     @pytest.mark.asyncio
     async def test_store_end_to_end(store_id):
         adapter = get_store_adapter(store_id)
         await adapter.start()
         try:
             assert await adapter.login()
             assert await adapter.search_vehicle(TEST_CAR_NUMBER)

             hist = await adapter.get_coupon_history(TEST_CAR_NUMBER)
             assert hist is not None

             # 선택: 공통 계산기로 plan 생성 → CouponApplication 리스트
             plan = []
             if hasattr(adapter, "plan_coupons"):
                 plan = await adapter.plan_coupons(TEST_CAR_NUMBER)
             if plan:
                 assert await adapter.apply_coupons(plan)
         finally:
             await adapter.cleanup()
     ```
   - 테스트는 **퍼블릭 API 호출 + assert**만 수행합니다.

4) `tests/legacy/` (선택)
   - 레거시 UI 중심 테스트 파일 이동 및 skip 처리.

5) `tests/README.md`
   - “테스트는 소스의 퍼블릭 API만 호출한다. DOM/셀렉터 조작 금지. 설정은 공용 로더 사용.”을 5~8줄로 명시.

---

## 🧷 품질 기준 (Definition of Done)

- `pytest -q -k store_e2e`가 모든 매장에 대해 실행되며,
  - 테스트 코드에는 **브라우저 생성/셀렉터/팝업/스크린샷/임의 sleep**이 없습니다.
  - **sys.path 해킹 없음**, 패키지 임포트 일관.
  - 설정은 전부 `infrastructure/config/loader.py` 경유.
- 매장별 차이를 **어댑터 계층**에서 흡수하여, 테스트 파일은 **단일 코드**로 모든 매장을 커버합니다.
- (있다면) 공통 쿠폰 계산기는 **계획 수립만 담당**하고, 적용은 **반드시 어댑터의 `apply_coupons()`** 경유합니다.
- CI에서 전 매장 파라미터 테스트가 병렬로 안정적으로 동작합니다.
- 레거시 테스트는 `tests/legacy/`로 격리되어 기본 실행에서 제외됩니다.

---

## 🔩 구현 세부 규칙

- **어댑터 작성 원칙**
  - 매장별 실제 크롤러의 메서드명이 달라도 테스트 표준 API에 맞춰 매핑하세요.
  - 동기화는 크롤러/어댑터 내부에서 **explicit wait**로 해결하고, 테스트에 노출하지 마세요.
  - 반환 타입은 공통 도메인 모델로 직렬화/정규화하세요(예: `CouponHistory` 공통 필드).

- **설정/시크릿**
  - `STORE_ID`·`BASE_URL`·자격증명·브라우저 옵션·타임존 등을 로더에서 주입합니다.
  - 로더는 `.env`/YAML/환경변수를 조합해 결정하며, 테스트와 실행이 **동일 경로**를 사용합니다.

- **테스트 데이터**
  - 차량번호 등 테스트 입력은
    1) 매장 공통으로 유효한 더미값, 또는
    2) 매장별 테스트 섹션을 설정에 두고 로더를 통해 주입합니다.
  - 하드코딩을 피하고 가능하면 환경변수 fallback을 사용합니다.

---

## 📑 진행 순서 제안

1) 공통 인터페이스/어댑터 초안 → `STORE_REGISTRY` 구성  
2) 공용 로더 정비 → 테스트/실행 동일 경로로 설정 주입  
3) `tests/e2e/test_store_e2e.py` 구현(파라미터화)  
4) 레거시 테스트 격리/정리  
5) CI에 `pytest -q -k store_e2e` 추가

---

## ⚠️ 주의

- **테스트에 비즈니스/DOM 로직을 다시 쓰지 마십시오.** 그 로직은 전부 크롤러/어댑터 내부로 옮기세요.  
- `wait_for_timeout`(고정 슬립) 금지. 상태 기반 대기로 안정화하세요.  
- 셀렉터/팝업/클릭 경로를 테스트에 넣지 마세요.  
- 민감정보는 절대 커밋하지 말고 로더를 통해서만 접근하세요.
