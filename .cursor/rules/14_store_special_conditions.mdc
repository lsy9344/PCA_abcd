---
title: "매장별 특수 조건 및 예외 처리"
order: 14
category: "business_logic"
tags: ["store", "special_conditions", "exceptions", "business_rules"]
lastUpdated: "2024-01-27"
description: "각 매장의 특수한 비즈니스 조건과 개발 시 주의사항"
---

# 매장별 특수 조건 및 예외 처리

> **매장마다 다른 특수한 비즈니스 조건과 이를 처리하는 방법을 정리한 가이드입니다.**

---

## 🏪 **A 매장 - 표준 기준점**

### **특수 조건**
- **주말 전용 쿠폰 보유**: 유일하게 `WEEKEND_COUPON` 타입을 가짐
- **쿠폰 명칭 특이사항**: "30분할인권(무료)"이지만 실제로는 60분 적용

### **개발 시 주의사항**
```python
# A 매장 주말 처리
if not is_weekday:
    # A 매장은 주말 전용 쿠폰 우선 사용
    if has_weekend_coupon:
        apply_weekend_coupon()
    else:
        apply_paid_coupon()  # fallback
```

### **테스트 케이스**
```python
# A 매장 주말 시나리오
target_minutes = 120  # 주말 2시간
expected_result = {
    'FREE_1HOUR': 1,      # 60분
    'WEEKEND_1HOUR': 1,   # 60분 (주말 전용)
    'PAID_1HOUR': 0       # 사용 안함
}
```

---

## 🏪 **B 매장 - 30분 유료 쿠폰 특화**

### **특수 조건**
1. **30분 단위 유료 쿠폰**: 다른 매장과 달리 30분 단위로 판매 (duration_minutes: 30)
2. **주말 쿠폰 없음**: WEEKEND 타입 부재, PAID로 fallback
3. **자동 계산 처리**: 동적 알고리즘이 duration_minutes 기반으로 자동 계산

### **동적 계산 알고리즘 자동 처리**
```python
# B 매장은 별도의 특수 계산 클래스가 불필요합니다!
# 동적 알고리즘이 자동으로 처리:

def calculate_dynamic_coupons(target_minutes, coupon_configs, ...):
    # ...
    for config in coupon_configs:
        if config.coupon_type == 'PAID':
            # B 매장: config.duration_minutes = 30
            # A 매장: config.duration_minutes = 60
            needed_count = math.ceil(remaining_minutes / config.duration_minutes)
            # ↑ 이 한 줄로 모든 매장의 다른 시간 단위를 자동 처리!
```

### **실제 적용 예시**
```python
# B 매장 평일 시나리오 (목표 3시간) - 자동 계산
target_minutes = 180
free_applied = 60        # 무료 1시간 (duration_minutes: 60)
remaining = 120          # 2시간 부족

# 동적 알고리즘 자동 계산:
# ceil(120분 / 30분) = 4개 (B 매장 30분 쿠폰)
needed_paid = math.ceil(remaining / 30)  # 4개

# 검증: 60분(무료) + 120분(30분×4) = 180분 ✅
# → 별도의 보정 로직 없이 완벽하게 처리됨!
```

### **비즈니스 의미**
- **비용 효율성**: 30분 단위로 세밀한 시간 조정 가능
- **사용자 편의**: 필요한 만큼만 정확히 구매 가능
- **시스템 단순성**: duration_minutes만 설정하면 자동 처리 ✅

---

## 🏪 **C 매장 - 2시간 무료 쿠폰 특화**

### **특수 조건**
1. **2시간 무료 쿠폰**: 유일하게 120분 무료 쿠폰 보유
2. **주말 목표 완전 달성**: 무료 쿠폰만으로 주말 목표(2시간) 달성 가능
3. **환경변수 로그인**: 보안을 위해 .env 파일 사용

### **시나리오별 처리**

#### **주말 시나리오 (목표 2시간)**
```python
# C 매장 주말: 무료 쿠폰만으로 완전 달성
target_minutes = 120
free_2hour_applied = 120  # 무료 2시간 쿠폰

result = {
    'FREE_2HOUR': 1,    # 120분으로 목표 달성
    'PAID_1HOUR': 0     # 추가 유료 쿠폰 불필요
}

# 효율성: 100% (추가 비용 없음)
```

#### **평일 시나리오 (목표 3시간)**
```python
# C 매장 평일: 무료 + 유료 조합
target_minutes = 180
free_2hour_applied = 120  # 무료 2시간
remaining = 60           # 1시간 부족

result = {
    'FREE_2HOUR': 1,    # 120분
    'PAID_1HOUR': 1     # 60분 (부족분 보충)
}

# 총 적용: 180분 (목표 달성)
```

### **비즈니스 의미**
- **주말 혜택**: 주말에 추가 비용 없이 목표 달성
- **차별화**: 다른 매장 대비 무료 혜택 확대
- **복잡도**: 2시간 단위 계산 로직 필요

---

## 🏪 **D 매장 - B 매장과 동일 구조 + 로그인 예외**

### **특수 조건**
1. **30분 유료 쿠폰**: B 매장과 동일 (duration_minutes: 30으로 자동 처리)
2. **비밀번호 만료 처리**: 추가적인 팝업 처리 필요
3. **복잡한 로그인 프로세스**: 다단계 인증 및 예외 처리

### **비밀번호 만료 처리**
```python
async def _handle_login_exceptions(self):
    """D 매장 특수 로그인 예외 처리"""
    
    # 비밀번호 만료 확인
    password_expired = self.page.locator("text=비밀번호가 만료되었습니다")
    if await password_expired.count() > 0:
        self.logger.log_error(ErrorCode.FAIL_AUTH, "로그인", 
                            "비밀번호 만료. 관리자 문의 필요")
        return False
    
    # 로그인 성공 지표 확인  
    success_indicator = self.page.locator("text=차량번호 뒤 4자리")
    if await success_indicator.count() > 0:
        return True
        
    return False
```

### **쿠폰 계산**
```python
# D 매장은 B 매장과 동일한 30분 단위 처리
# duration_minutes: 30 설정으로 자동 계산 (별도 로직 불필요)
```

---

## ⚙️ **매장별 특수 로직 통합 관리**

### **통합된 동적 계산 시스템**
```python
# 모든 매장이 동일한 DiscountCalculator 사용!
# Factory 패턴이나 매장별 특수 클래스 불필요

class DiscountCalculator:
    """범용 할인 계산기 - 모든 매장 공통 사용"""
    
    def __init__(self, policy: DiscountPolicy, coupon_configs: List[CouponConfig]):
        self.policy = policy
        self.coupon_configs = coupon_configs  # YAML에서 로드된 설정
    
    def calculate_required_coupons(self, ...):
        return calculate_dynamic_coupons(  # 범용 알고리즘
            coupon_configs=self.coupon_configs  # 매장별 duration_minutes 자동 적용
        )
```

### **간소화된 검증 로직**
```python
def validate_result(coupon_configs: List[CouponConfig], result: Dict[str, int], target_minutes: int) -> bool:
    """매장 무관 범용 검증 - duration_minutes 기반"""
    
    total_applied_minutes = 0
    
    # 모든 매장 공통: duration_minutes 기반 시간 계산
    for coupon_key, count in result.items():
        config = next((c for c in coupon_configs if c.coupon_key == coupon_key), None)
        if config:
            total_applied_minutes += count * config.duration_minutes
    
    # 목표 달성 여부 확인 (매장별 특수 로직 불필요)
    return total_applied_minutes >= target_minutes
```

---

## 🔧 **새로운 매장 추가 시 고려사항**

### **특수 조건 분류**

#### **1. 시간 관련 특수 조건**
```yaml
# 예시: 45분 단위 쿠폰 매장
coupons:
  PAID_COUPON:
    duration_minutes: 45  # 특수한 시간 단위
    
# 처리: 동적 계산 알고리즘이 자동 처리 (추가 코드 불필요)
```

#### **2. 비즈니스 로직 특수 조건**
```python
# 예시: 무료 쿠폰 2개 사용 가능한 매장
# → YAML 설정으로 처리 가능!
coupons:
  FREE_COUPON_1:
    name: "첫번째 무료쿠폰"
    type: "FREE"
    duration_minutes: 60
    priority: 0
  FREE_COUPON_2:
    name: "두번째 무료쿠폰"  
    type: "FREE"
    duration_minutes: 60
    priority: 1
# → 동적 알고리즘이 자동으로 2개까지 적용!
```

#### **3. 웹사이트 구조 특수 조건**
```python
# 예시: 복잡한 인증 프로세스
async def _handle_multi_step_auth(self):
    # 1단계: 기본 로그인
    await self._basic_login()
    
    # 2단계: OTP 인증 (특수)
    await self._handle_otp_verification()
    
    # 3단계: 추가 약관 동의 (특수)
    await self._handle_terms_agreement()
```

### **특수 조건 문서화 템플릿**
```markdown
## 🏪 **[매장명] - [특징 요약]**

### **특수 조건**
1. **[조건 1]**: 설명
2. **[조건 2]**: 설명

### **계산 알고리즘 특수 처리**
```python
# 코드 예시
```

### **비즈니스 의미**
- **장점**: 설명
- **단점**: 설명
- **고려사항**: 설명
```

---

## 📊 **매장별 특수성 요약**

| 매장 | 주요 특수 조건 | 개발 복잡도 | 비즈니스 의미 |
|------|---------------|------------|--------------|
| **A** | 주말 전용 쿠폰 | 낮음 | 표준 기준점 |
| **B** | 30분 유료 단위 | **낮음** ✅ | 세밀한 시간 조정 |
| **C** | 2시간 무료 쿠폰 | **낮음** ✅ | 주말 혜택 확대 |
| **D** | 로그인 예외 처리 | 중간 | 보안 강화 |

---

## 🎯 **개발자 가이드라인**

### **특수 조건 처리 원칙**
1. **YAML 설정 우선**: 99%의 경우 duration_minutes 설정만으로 해결
2. **코드 최소화**: 동적 알고리즘 신뢰, 특수 로직 지양
3. **재사용성**: 모든 매장이 동일한 계산 로직 사용
4. **문서화**: 진짜 특수한 조건만 문서화 (쿠폰 시간은 제외)

### **새로운 특수 조건 추가 프로세스**
1. **분석**: 기존 패턴과 비교하여 유사성 확인
2. **설계**: 설정으로 처리 가능한지 검토
3. **구현**: 최소한의 코드로 구현
4. **테스트**: 특수 케이스 테스트 작성
5. **문서화**: 이 문서에 추가

---

**매장별 특수 조건을 이해하고 적절히 처리하여 안정적인 시스템을 구축하세요!**